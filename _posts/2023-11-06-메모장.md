---
title: "문제와 원인 해결을 모아 놓은 메모장"
excerpt: '프로젝트를 수행하면서 겪은 문제를 모아모아'
categories:
  - Blog
tags:
  - SpringBoot
  - JSP



toc: true               #Table Of Contents 목차 
author_profile: true    #작성자 프로필 출력 여부
toc_sticky: true
last_modified_at: 2023-11-06T14:20:00+09:00
---

문제: jsp 파일을 찾을 수 없음<br>
원인: 내장된 tomcat에 jsp를 처리하는 서블릿이 없음<br>
해결: build.gradle이나 pom.xml 등에 jsp 처리하는 서블릿을 추가해주고 refresh


Maven 기준
```xml
<dependency>
	<groupId>org.apache.tomcat.embed</groupId>
	<artifactId>tomcat-embed-jasper</artifactId>
</dependency>
```
img

문제: jsp파일 내 정적 리소스파일을 찾지 못하여 이미지가 깨지는 현상<br>
원인: ~~정적리소스 파일 경로가 webapp 하위 경로로 지정되어 있지않아 파일을 찾지 못함<br> 
해결: application.properties에 static-locations을 지정해준다.<br>
```html
<div id="warp">
        <h1><img src="resources/images/tit_01.gif"
             alt="서비스"
             width="188"
             height="18"></h1>
</div>
```

문제: jsp파일 내에서 window.open함수를 사용해서 페이지 이동 시키려고 하는데 whiteblank페이지가 나옴<br>
원인: '도메인이 없는 상태'?에서 페이지 이동을하려고 하는 경우 mapping이 되어있어야 함<br>
해결: Controller에서 이동용 Getmapping을 생성<br>

```javascript
function jusoPopup() {
    window.open("/jusoPopup", "pop", "width=570, height=420, scrollbars=yes");
}
```
```java
    @RequestMapping("/jusoPopup")
    public String jusoPopup(){
        return "menu/jusoPopup";
    }
```

참고 블로그 - https://needjarvis.tistory.com/771

문제: springboot mybatis 연동 시 config를 SqlSessionFactory를 사용할 지, mybatis-config.xml파일로 따로 만들어서 사용할지 정해야함<br>
원인: <br>
해결: <br>


getter 쓰지말라고만 하고 가버리면 어떡해요


객체의 제약조건을 외부에서 지정하여 사용할 때의 문제점 
- 객체 내부의 값을 조작할 때 지켜야 하는 규칙들이 도메인 객체 내부가 아니라 외부의 객체들에 의해 조작되고 흩어져 구현되어있기 때문에
어떤곳에서는 지켜지고 어떤곳에서는 안지켜지는 문제가 발생

객체 변수를 private으로 선언하고 사용하더라도 각 값마다 조회 함수와 설정 함수를 제공한다면 구현을 외부로 노출하는 셈이다
-> 변수 사이에 함수라는 계층을 넣었다고해서 구현이 저절로 감추어지는것이 아니다.
-> .getMallId();


개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.
아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.
- 클린 코드 中

프로그래머스 -정수 삼각형

``` java
    public int solution(int[][] triangle) {
        int answer = 0;
        int[][] temp = new int[triangle.length][triangle.length];
        temp[0][0] = triangle[0][0];
        
        for (int i = 1; i < triangle.length; i++) {
            temp[i][0] = temp[i - 1][0] + triangle[i][0];
            for (int j = 1; j <= i; j++) {
                temp[i][j] = Math.max(temp[i - 1][j], temp[i - 1][j - 1]) + triangle[i][j];
            }
        }
        
        for (int i = 0; i < triangle.length; i++) {
            answer = Math.max(answer, dp[triangle.length - 1][i]);
        }
        return answer;
    }
```
풀이를 보고 생각해보자


``` java 
DFS알고리즘 

  // 'solution' 메서드: 변환 시작 단어(begin), 목표 단어(target), 가능한 단어 목록(words)을 입력받음
    public int solution(String begin, String target, String[] words) {
        boolean[] visited = new boolean[words.length];  // 단어 방문 여부를 추적하는 배열
        int answer = dfs(begin, target, words, 0, visited);  // 깊이 우선 탐색(dfs)를 시작하여 결과값을 받음
        return answer;  // 최종 결과 반환
    }

    // 'dfs' 메서드: 현재 단어(current), 목표 단어(target), 단어 목록(words), 현재까지의 변환 횟수(count), 방문 여부 배열(visited)를 입력받음
    private static int dfs(String current, String target, String[] words, int count, boolean[] visited) {
        if (current.equals(target)) {  // 현재 단어가 목표 단어와 일치하는 경우
            return count;  // 현재까지의 변환 횟수 반환
        }

        int minCount = Integer.MAX_VALUE;  // 최소 변환 횟수를 저장할 변수
        for (int i = 0; i < words.length; i++) {  // 가능한 모든 단어에 대해 반복
            if (!visited[i] && isOneLetterDiff(current, words[i])) {  // 방문하지 않았고, 한 글자만 다른 단어인 경우
                visited[i] = true;  // 해당 단어 방문 처리

                //        String[] words2 = new String[]{"hot", "dot", "dog", "lot", "log"}; cog
                                    // hot,
                int tempCount = dfs(words[i], target, words, count + 1, visited);  // 재귀적으로 dfs 호출
                if (tempCount < minCount) {
                    minCount = tempCount;  // 최소 변환 횟수 갱신
                }
                visited[i] = false;  // 방문 처리 해제
            }
        }

        return minCount == Integer.MAX_VALUE ? 0 : minCount;  // 변환 가능한 경우가 없으면 0 반환, 아니면 최소 횟수 반환
    }

    // 'isOneLetterDiff' 메서드: 두 단어(word1, word2)가 한 글자만 다른지 확인
    private static boolean isOneLetterDiff(String word1, String word2) {
        int diffCount = 0;  // 다른 글자의 수
        for (int i = 0; i < word1.length(); i++) {  // 각 글자를 비교
            if (word1.charAt(i) != word2.charAt(i)) {
                diffCount++;  // 다른 글자 발견 시 카운트 증가
            }
        }
        return diffCount == 1;  // 다른 글자가 정확히 하나인 경우 true 반환
    }

```