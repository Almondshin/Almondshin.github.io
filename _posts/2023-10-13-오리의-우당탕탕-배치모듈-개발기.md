---
title: "오리의 우당탕탕 배치모듈 개발"
excerpt: '배치 모듈 개발기'
categories:
  - Blog
tags:
  - Transaction
  - batch
  - lists
  - SQL


toc: true               #Table Of Contents 목차 
author_profile: true    #작성자 프로필 출력 여부
toc_sticky: true
last_modified_at: 2023-10-18T09:00:00+09:00

---
새로운 일상, 새로운 기회. <br>
오리는 따뜻한 커피 한 잔을 손에 들고 사무실에 앉았어요.  
오리는 대용량 데이터를 가공하여 통계를 낼 수 있는 배치 모듈 개발을 담당하게 됐어요.  
서비스를 운영 및 관리하면서 <br>
프로세스는 나름 잘 알게 되었다고 자신하며 프로젝트를 시작한 오리

> 서비스는 **[A,B,C,D]** 4가지로 이루어져 있고, 데이터는 하루에는 대략 30 ~ 50만 건이 쌓인다고 해요.

>  아래는 프로젝트 시작 전 전달받았던 요구사항이에요.
>1. 데이터를 [10분, 일별, 월별] 단위로 나누어 처리해야 해요.
>2. 다중화된 서버 환경에서의 데이터 처리를 고려해야 해요.
>3. 30분 이전의 데이터를 통계 내어야 해요
>4. 결과 통계가 명확해야 해요.


### 데이터 동기화와 쿼리 최적화

오리는 생각했어요.<br>
"4개의 서비스의 사용 건수를 10분 단위로 집계하고<br>
10분 단위로 집계된 데이터를 다시 일별로 집계하고<br>
마찬가지로 월별도 일별을 집계하는 방식으로 가면 되겠구나."<br>

오리는 서비스별로 쌓이는 데이터를 하나로 합칠 필요가 있었어요.<br>
10분 단위, 하루 단위, 한 달 단위로 통계 테이블을 각각 생성하고, 관리해야 했어요.<br>

실시간으로 대량의 데이터가 쌓이는 상황에서, 여러 테이블과 데이터베이스 간의 효율적인 데이터 처리 방안을 고려하게 됐어요.

![img](/assets/img/통계오리.png)

> 오리가 떠올린 고려사항과 방법은 다음과 같아요.<br>
> A. 다중화된 서버 환경에서 데이터 처리 작업의 분산 및 병렬 처리<br>
> B. 데이터의 일관성과 정확성을 유지하면서 빠른 처리가 가능한 DB 쿼리 최적화 방안<br>
> C. 코드를 알아보기 쉽고 유지보수하기 편하게 만들자

오리는 데이터의 일관성과 처리 속도를 동시에 고려하기 위해 조회와 삽입 작업을 동시에 수행하는 쿼리를 작성하기로 했어요.

``` sql
INSERT INTO 테이블
(X_DATE, A_ID, B_ID, C_ID, D_TYPE, E_CNT, F_CNT, G_CNT, H_CNT, I_DATE)
SELECT '현재시간' AS X_DATE
     , A_ID
     , B_ID
     , C_ID
     , '지정된타입' AS D_TYPE
     , COUNT(E_TX_ID) AS E_CNT
     , COUNT(
          CASE            
          WHEN F_TYPE = 'fTypeA' AND G_CODE IN ('1234')
                  OR F_TYPE = 'fTypeB'
                  OR F_TYPE = 'fTypeC'
                  THEN 1
              END
       ) AS F_CNT
     , COUNT(
          CASE            
          WHEN F_TYPE = 'fTypeC' AND G_CODE IN ('1234')
                  OR F_TYPE = 'fTypeB' AND G_CODE IN ('1234')
                  THEN 1
              END
       ) AS G_CNT
     , COUNT(E_TX_ID) - COUNT(
          CASE            
          WHEN F_TYPE = 'fTypeA' AND G_CODE IN ('1234')
                  OR F_TYPE = 'fTypeB'
                  OR F_TYPE = 'fTypeC'
                  THEN 1
              END
       ) AS H_CNT
     , '시간 변수' AS I_DATE
FROM LMNOP_TBL
WHERE 1 = 1
  AND I_DATE >= '조회시간'
  AND I_DATE < '조회시간'
GROUP BY B_ID, C_ID, A_ID

```

조회와 삽입을 하나의 쿼리에서 진행하다보니 쿼리 최적화가 필요했고,<br>
DB 인덱싱을 통해 오랜시간 DB를 점유하는 것을 최소화 시켰어요.

<img src="/assets/img/하찮은 오리.png" width="50%" height="50%"/>

#### 분리하여 사용하는 방법의 장단점  
> **장점**:
> 1. **명확한 로직 분리와 확장성**: 조회와 삽입 로직이 분리되어 있기 때문에 각 기능별로 코드를 사용할 수 있고, 활용해서 사용할 수 있어요.
> 2. **유연한 유지보수**: 한 쪽의 로직만 변경해야 할 경우, 다른 쪽에 영향을 미치지 않아 유지보수가 편리해요.
> 3. **오류 예방**: 삽입과 조회 중 하나에서 오류가 발생하더라도 다른 로직에는 영향을 미치지 않아요.
>
>**단점**:
>1. **통신 횟수 증가**: 조회와 삽입이 따로 이루어지기 때문에, 데이터베이스와의 통신 횟수가 증가해요. 이로 인해 전체적인 처리 시간이 길어질 수 있어요.
>2. **트랜잭션 관리 어려움**: 조회 후 삽입이 이루어져야 하는 상황에서는 트랜잭션 관리가 복잡해질 수 있어요.
>3. **일관성 유지의 어려움**: 조회와 삽입이 따로 이루어질 경우, 조회 후에 데이터 상태가 변경될 가능성이 있어, 삽입 시점의 데이터 일관성 유지가 어려울 수 있어요.
>4. **복잡한 예외 처리**: 조회와 삽입 작업이 따로 이루어지면, 각각의 작업에서 발생할 수 있는 예외 상황을 따로 처리해야해요.
>5. **리소스 비효율**: 두 개의 쿼리를 실행하기 때문에, 리소스 사용량이 증가하며, 이로 인해 전반적인 시스템 퍼포먼스가 저하될 수 있어요.

#### 조회와 삽입 작업을 동시에 수행하는 쿼리의 장단점:
>**장점**:
>1. **통신 횟수 감소**: 단 한 번의 쿼리로 두 가지 작업을 처리할 수 있기 때문에, DB와의 통신 횟수를 줄일 수 있습니다.
>2. **일관성 보장**: 조회와 삽입이 동시에 이루어지므로, 데이터의 일관성을 보장할 수 있습니다.
>3. **트랜잭션 관리의 간소화**: 하나의 쿼리에서 처리되기 때문에 트랜잭션 관리가 더욱 간편해집니다.
>
**단점**:
>
>1. **로직 복잡성**: 조회와 삽입을 동시에 처리하는 쿼리는 로직이 복잡해질 수 있으며, 이로 인해 유지보수가 어려워질 수 있습니다.
>2. **오류 예방의 어려움**: 쿼리에 오류가 발생하면, 조회와 삽입 둘 다에 문제가 생길 수 있습니다. 이 경우, 오류의 원인 파악이 복잡해질 수 있습니다.
>3. **튜닝의 어려움**: 동시에 수행하는 쿼리는 최적화하기가 더 어려울 수 있습니다.


오리는 다중화된 서버 환경에서 자신이 만든 모듈을 배포하게 된다고하니 생각이 많아졌어요.<br>
데이터가 삽입되는도중 데드락이 걸리면안돼..<br>

오리는 데이터의 순차적인 삽입 처리를 위해 DB lock 테이블을 생성해요.<br>

#### DB lock 테이블을 사용한 스케줄링 로직 관리
오리는 데이터베이스에 해당 타겟 메서드가 실행되었을 때의 시간과 실행된 서비스 이름을<br>
DB lock 테이블에 저장하여 관리했어요.<br>
이렇게 하면 동시에 같은 데이터를 수정하려는 다른 요청이나 스케쥴러 작업을 효과적으로 방지할 수 있어요.<br>


## 데이터 동기화와 동시성 관리

그런데 어느날!<br>
서비스를 이용하는 업체가 이벤트를 진행했고,<br>
이 이벤트는 예상을 뛰어넘는 선풍적인 인기를 끌었고,<br>
사용자들의 폭발적인 참여로 인해 데이터 처리가 복잡해졌어요.<br>
이로 인해 통계 데이터 처리하는 과정에도 여러 문제를 발견하게 되었어요.<br>
SQLIntegrityConstraintViolationException: Duplicate entry 오류와<br>
java.sql.SQLSyntaxErrorException :  Truncated incorrect DOUBLE value: ''오류가 발생했었어요.

![img](/assets/img/오리 폭발.png)

대량의 오류 코드를 찍고있던 배치모듈을 정지시키고 나서 생각했어요.<br>
이미 인서트 되어있는 데이터와 다음 트랜잭션의 데이터와 동시에 얽히면서 발생한 중복오류인지,<br>
데이터 자체에 중복값이 들어와서 발생한 문제인지 알 수가 없었어요.<br>

하루동안 통계 데이터를 집계하지 못한 오리는 서비스에 대한 사과문을 쓰고 <br>
다음에 또 이런일이 발생하더라도 오리가 핸들링 할 수 있도록 하는 방법을 공부해 적용하기로 합니다.<br>


### `@Transactional`을 조금 더 활용해보자

오리는 데이터의 안정성과 정확성을 위해, `@Transactional` 어노테이션의 활용을 알아보기로요.<br>
1. 일관성 보장 : `@Transactional` 어노테이션이 붙은 메서드는 실행 중에 예외가 발생하면 자동으로 롤백이 되어 데이터의 일관성을 보장해요.<br>
   !단 모든 예외에대해서 롤백을 시켜주지 않아요.<br>
2. 선언적 트랜잭션 관리 : 코드 기반의 트랜잭션 관리보다 어노테이션을 사용하는 선언적 트랜잭션 관리가 훨씬 간결하고 직관적이에요.

### 롤백 처리의 깊은 고려

`@Transactional` 어노테이션은 데이터의 일관성을 보장하기 위해 예외 발생 시 트랜잭션을 롤백하는 기능을 제공해요.<br>
하지만!!  모든 예외가 데이터의 일관성을 위협하지 않기 때문에, 스프링은 특정 예외에 대해서만 기본적으로 롤백을 수행한다고 해요.<br>

1. **기본 롤백 규칙**:
   스프링의 `@Transactional`에서는 런타임 예외(`RuntimeException`)와 `Error`가 발생했을 때 기본적으로 롤백을 수행합니다. 반면, 체크 예외(`checked exceptions`)는 롤백 대상에서 제외됩니다. 이는 체크 예외가 일반적으로 복구 가능한 예외로 간주되기 때문입니다.

2. **롤백 설정의 커스터마이징**:
   `@Transactional` 어노테이션의 `rollbackFor` 속성을 사용하여 롤백을 수행할 예외를 명시적으로 지정할 수 있습니다. 또한, `noRollbackFor` 속성을 사용하여 롤백을 하지 않을 예외를 지정할 수도 있습니다.

```java
@Transactional(rollbackFor = CustomException.class)
```

3. **프로그래밍적 롤백**:
   때로는 코드 내에서 조건에 따라 롤백을 수행해야 할 경우가 있습니다. 이럴 때는 `TransactionAspectSupport`의 `currentTransactionStatus().setRollbackOnly()` 메서드를 호출하여 프로그래밍적으로 롤백을 수행할 수 있습니다.

```java

@Service  
public class MyService {  
  
    @Transactional  
    public void myTransactionalMethod() {  
        try {  
            // 어떤 조건에 따라 롤백을 수행하고 싶을 때  
            if (someCondition()) {  
                // 프로그래밍적으로 롤백 수행  
                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  
                return;  
            }  
  
            // ... 다른 비즈니스 로직 ...  
        } catch (SpecificException1 e1) {  
            // 특정 예외에 대한 처리 로직  
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  
        } catch (SpecificException4 e2) {  
            // 롤백을 수행하지 않는 예외 처리 로직  
        } catch (Exception e) {  
            // 그 외의 예외에 대한 처리 로직  
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  
        }  
    }  
  
    private boolean someCondition() {  
        // 임의의 조건  
        return true;  
    }  
}


```

오리는 롤백 처리하는 다양한 방법에 대해 공부해보고 예외 상황에서도 데이터의 일관성과 안정성을 유지할 수 있는 방법을 배웠습니다.

---  

이를 바탕으로 동시성 관리 전략을 효과적으로 적용하면, 데이터의 안정성과 처리 속도를 동시에 달성할 수 있게 되었어요.

**이번 프로젝트는 혼자서 프로젝트를 진행하며 다양한 기술과 환경을 접하게 되었는데, 다양한 기술이 있더라도 그 중에서도 본인에게 꼭 필요한 기술인지 고민하여 적용하는 것**이 중요하다는 깨달음을 얻었습니다. 😊
